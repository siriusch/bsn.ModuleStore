! -----------------------------------------------------------------------------------
! T-SQL Script Analyzer
! -----------------------------------------------------------------------------------

"Name"         = 'T-SQL CREATE Statements'
"Version"      = '2005'
"About"        = 'Parser for T-SQL CREATE statements to get names'
"Author"       = 'Arsene von Wyss'

"Start Symbol" = <Root>

! =============================================================================
! Comments
! =============================================================================

Comment Start = '/*'
Comment End   = '*/'
Comment Line  = '--'

! =============================================================================
! Terminals
! =============================================================================

{String Ch}        = {Printable} - ["]
{Id Ch Standard}   = {Alphanumeric} + [_]
{Id Ch Extended}   = {Printable} - ['['#']']
{Hex Ch}           = [0123456789ABCDEF]
{Nonspace Ch}      = {Printable} - {Whitespace}

StringLiteral   = N?(''{String Ch}*'')+
IntegerLiteral  = {Digit}+
RealLiteral     = {Digit}+'.'{Digit}+
HexLiteral      = 0x{Hex Ch}+

! We use a simplified name convention, which does not allow user/schema, database or server to be specified
Id             = {Letter}{Id Ch Standard}* | '['{Id Ch Extended}+']' | '"'{Id Ch Standard}*'"'
LocalId        = '@'{Letter}{Id Ch Standard}*
SystemId       = '@@'{Letter}{Id Ch Standard}*
TempTableId    = '#'{Letter}{Id Ch Standard}* | '[#'{Id Ch Extended}+']' | '"#'{Id Ch Standard}*'"'
!NamespaceId    = {Letter}{Id Ch Standard}*':'{Nonspace Ch}+

! =============================================================================
! Common Terminals (Names, Literals, ...)
! =============================================================================

<AliasName> ::= Id

<CollationName> ::= Id

<ColumnName> ::= Id

<ColumnNameQualified> ::= <ColumnName>
                        | <TableName> '.' <ColumnName>

<ColumnNameList> ::= <ColumnName> ',' <ColumnNameList>
                   | <ColumnName>

<ColumnWild> ::= '*'

<ColumnWildQualified> ::= <ColumnWild>
                        | <TableName> '.' <ColumnWild>

<ColumnWildNameQualified> ::= <ColumnNameQualified>
                            | <ColumnWildQualified>

<FunctionName> ::= Id

<IndexName> ::= Id

<LabelName> ::= Id

<ParameterName> ::= LocalId

<TableName> ::= Id
              | TempTableId

<TableNameQualified> ::= <TableName>
                       | <SchemaName> '.' <TableName>

<TypeName> ::= Id

<TypeNameQualified> ::= <TypeName>
                      | <SchemaName> '.' <TypeName>

<SchemaName> ::= Id

<SystemVariableName> ::= SystemId

<VariableName> ::= LocalId

<XmlElementName> ::= Id

<XmlNamespaceName> ::= Id

<LCID> ::= HexLiteral
         | IntegerLiteral
         | StringLiteral

<OptionalAs> ::= AS
               |

<NullLiteral> ::= NULL

<OptionalNot> ::= NOT
                |

<NullCheck> ::= <OptionalNot> <NullLiteral>

<StringLiteral> ::= StringLiteral

<IntegerLiteral> ::= IntegerLiteral
                   | HexLiteral

<NumberLiteral> ::= <IntegerLiteral>
                  | RealLiteral

<Literal> ::= <NumberLiteral>
            | <StringLiteral>
            | <NullLiteral>

<Toggle> ::= Id

! =============================================================================
! Any statements allowed as SQL statements in code
! =============================================================================

<Root> ::= <StatementGroup>
         | <Statement>

! In T-SQL, the terminator (;) is usually not required. However, this introduces some ambiguities, so that we require it. 
<StatementGroup> ::= <StatementBlock>
                   | <Statement> ';'

<StatementBlock> ::= BEGIN <StatementList> END

<StatementList> ::= <StatementGroup> <StatementList>
                  | <StatementGroup>

<Statement> ::= <BreakStatement>
              | <ContinueStatement>
              | <GotoStatement>
              | <IfStatement>
              | <ReturnStatement>
              | <TryCatchStatement>
!              | <WaitforStatement>
              | <WhileStatement>
              | <SelectStatement>
!              | <InsertStatement>
!              | <UpdateStatement>
!              | <DeleteStatement>
              | <CreateStatement>
              | <DropStatement>
!              | <AlterStatement>

<CreateStatement> ::= <CreateFulltext>
                    | <CreateFunction>
                    | <CreateIndex>
!                    | <CreateProcedure>
!                    | <CreateTable>
!                    | <CreateTrigger>
!                    | <CreateView>
!                    | <CreateXmlSchemaCollection>

<DropStatement> ::= <DropFulltext>
                    | <DropFunction>
                    | <DropIndex>
!                    | <DropProcedure>
!                    | <DropTable>
!                    | <DropTrigger>
!                    | <DropView>
!                    | <DropXmlSchemaCollection>

! =============================================================================
! Control-of-Flow statements
! =============================================================================

<BreakStatement> ::= BREAK

<ContinueStatement> ::= CONTINUE

<GotoStatement> ::= GOTO <LabelName>

<IfStatement> ::= IF <Predicate> THEN <IfElseStatement>

! To avoid the hanging ELSE problem/ambiguity, we just require a block - even if this is more restrictive than T-SQL
<IfElseStatement> ::= <StatementBlock> ELSE <StatementGroup>
                    | <StatementGroup>

<ReturnStatement> ::= RETURN
                    | RETURN <Expression>

<TryCatchStatement> ::= BEGIN TRY <StatementList> END TRY BEGIN CATCH <StatementList> END CATCH

<WhileStatement> ::= WHILE <Expression> <StatementGroup>

! =============================================================================
! Parameter Lists for Functions and Procedures
! =============================================================================

<OptionalDefault> ::= '=' <Literal>
                    |

! =============================================================================
! CREATE/DROP FULLTEXT
! =============================================================================

! We don't allow to specify the catalog name, since the catalog is automatically assigned (module name)

<CreateFulltext> ::= CREATE FULLTEXT INDEX ON TABLE <TableName> <FulltextColumnGroup> KEY INDEX <IndexName> <FulltextChangeTracking>

<FulltextColumnGroup> ::= '(' <FulltextColumnList> ')'
                        |

<FulltextColumnList> ::= <FulltextColumn> ',' <FulltextColumnList>
                       | <FulltextColumn>

<FulltextColumn> ::= <ColumnName> <FulltextColumnType> <FulltextColumnLanguage>

<FulltextColumnType> ::= TYPE COLUMN <TypeNameQualified>
                       |

<FulltextColumnLanguage> ::= LANGUAGE <LCID>
                           |

<FulltextChangeTracking> ::= WITH CHANGE_TRACKING <FulltextChangeTrackingName>
                           |

<FulltextChangeTrackingName> ::= MANUAL
                               | AUTO
                               | OFF
                               | OFF ',' NO POPULATION

<DropFulltext> ::= DROP FULLTEXT INDEX ON <TableName>

! =============================================================================
! CREATE/DROP FUNCTION
! =============================================================================

! We don't allow to specify the schema name, it is implicit (module name)

<CreateFunction> ::= CREATE FUNCTION <FunctionName> <FunctionParameterGroup> RETURNS <FunctionType>

<FunctionParameterGroup> ::= '(' <FunctionParameterList> ')'
                           | '(' ')'

<FunctionParameterList> ::= <FunctionParameter> ',' <FunctionParameterList>
                          | <FunctionParameter>

<FunctionParameter> ::= <ParameterName> <OptionalAs> <TypeNameQualified> <OptionalDefault>

<FunctionType> ::= <FunctionScalar>
                 | <FunctionInline>
                 | <FunctionTable>

<FunctionScalar> ::= <TypeName> <FunctionOptionGroup> <OptionalAs> <StatementBlock>

<FunctionInline> ::= TABLE <FunctionOptionGroup> <OptionalAs> RETURN <FunctionInlineSelect>

<FunctionInlineSelect> ::= <SelectStatement>
                         | '(' <SelectStatement> ')'

<FunctionTable> ::= <VariableName> TABLE <TableTypeDefinitionGroup> <FunctionOptionGroup> <OptionalAs> <StatementBlock>

<FunctionOptionGroup> ::= WITH <FunctionOption>
                        |

! The options ENCRYPTION and SCHEMABINDING are handled by the module and therefore not allowed
<FunctionOption> ::= RETURNS NULL ON NULL INPUT
                   | CALLED ON NULL INPUT

<DropFunction> ::= DROP FUNCTION <FunctionName>

! =============================================================================
! CREATE/DROP INDEX
! =============================================================================

! We don't support the ON option, filegroup is managed by module manager

<CreateIndex> ::= CREATE <ConstraintUnique> <ConstraintCluster> INDEX <IndexName> ON <TableName> '(' <IndexColumnList> ')' <IndexInclude> <IndexOptionGroup>
                | CREATE <IndexPrimary> XML INDEX <IndexName> ON <TableName> '(' <ColumnName> ')' <IndexUsing> <IndexOptionGroup>

<IndexColumnList> ::= <IndexColumn> ',' <IndexColumnList>
                    | <IndexColumn>

<IndexColumn> ::= <ColumnName> <OrderType> 

<IndexInclude> ::= INCLUDE '(' <ColumnNameList> ')'

<IndexPrimary> ::= PRIMARY
                 |

<IndexOptionGroup> ::= WITH '(' <IndexOptionList> ')'
                     |

<IndexOptionList> ::= <IndexOption> ',' <IndexOptionList>
                    | <IndexOption>

<IndexOption> ::= <IndexOptionMaxdop>
                | <IndexOptionFillfactor>
                | <IndexOptionToggle> '=' <Toggle>

<IndexOptionMaxdop> ::= MAXDOP '=' <IntegerLiteral>

<IndexOptionFillfactor> ::= FILLFACTOR '=' <IntegerLiteral>

<IndexOptionToggle> ::= PAD_INDEX
                      | IGNORE_DUP_KEY
                      | STATISTICS_NORECOMPUTE
                      | ALLOW_ROW_LOCKS
                      | ALLOW_PAGE_LOCKS
                      | SORT_IN_TEMPDB
                      | DROP_EXISTING
                      | ONLINE

<IndexUsing> ::= USING XML INDEX <IndexName> <IndexFor>
               |

<IndexFor> ::= FOR <IndexForValue>
             |

<IndexForValue> ::= VALUE
                  | PATH
                  | PROPERTY

<DropIndex> ::= DROP INDEX <IndexName> ON <TableName> <IndexOptionGroup>

! =============================================================================
! Table/Column Type Definitions
! =============================================================================

<TableTypeDefinitionGroup> ::= '(' <TableTypeDefinitionList> ')'

<TableTypeDefinitionList> ::= <TableTypeDefinition> ',' <TableTypeDefinitionList>
                            | <TableTypeDefinition>

! This does not match the BNF in the SQL Books Online 2005, but seems to be the correct syntax
<TableTypeDefinition> ::= <ColumnDefinition>
                        | <ColumnComputedDefinition>
                        | CONSTRAINT <ColumnName> <TableConstraintList>

<TableConstraintList> ::= <TableConstraint> <TableConstraintList>
                        | <TableConstraint>

<TableConstraint> ::= <ConstraintPrimaryKey> <ConstraintCluster> <ConstraintIndex>
                    | <ConstraintCheck>

<ColumnDefinition> ::= <ColumnName> <TypeNameQualified> <ColumnKind> <ColumnConstraintGroup>

<ColumnKind> ::= <ColumnIdentity>
               | <ColumnRowguid>
               | <ColumnDefault> <ColumnCollate>

<ColumnIdentity> ::= IDENTITY <ColumnIdentityRange>

<ColumnIdentityRange> ::= '(' IntegerLiteral ',' IntegerLiteral ')'
                        |

<ColumnRowguid> ::= ROWGUIDCOL

<ColumnDefault> ::= DEFAULT <Literal>
                  |

<ColumnCollate> ::= COLLATE <CollationName>
                  |

<ColumnConstraintGroup> ::= <ColumnConstraintList>
                          |

<ColumnConstraintList> ::= <ColumnConstraint> <ColumnConstraintList>
                         | <ColumnConstraint>

! The syntax for multiple the constraint checks is not clear from the grammar in the SQL Books 2005
<ColumnConstraint> ::= <NullCheck>
                     | <ConstraintPrimaryKey> <ConstraintCluster> <ConstraintIndex>
                     | <ConstraintCheck>

<ColumnComputedDefinition> ::= <ColumnName> AS <Expression>

<ConstraintPrimaryKey> ::= PRIMARY KEY
                         | UNIQUE

<ConstraintUnique> ::= UNIQUE
                     |

<ConstraintCluster> ::= CLUSTERED
                      | NONCLUSTERED
                      |

<ConstraintCheck> ::= CHECK '(' <Expression> ')'

<ConstraintIndex> ::= WITH <IndexOptionFillfactor>
                    | <IndexOptionGroup>

! =============================================================================
! Common Table Expressions
! =============================================================================

<CTEGroup> ::= WITH <CTEList>
             |

<CTEList> ::= <CTE> ',' <CTEList>
            | <CTE>

<CTE> ::= <AliasName> AS '(' <SelectGroup> ')'

! =============================================================================
! SELECT Statement
! =============================================================================

<SelectStatement> ::= <CTEGroup> <SelectGroup> <SelectFor>

<SelectGroup> ::= SELECT <Top> <Columns> <IntoClause> <FromClause> <UnionClause>

<Top> ::= TOP IntegerLiteral
        | TOP <VariableName>
        |

<Columns> ::= <Restriction> <ColumnList>

<ColumnList> ::= <ColumnItem> ',' <ColumnList>
               | <ColumnItem>

<ColumnItem> ::= <ColumnWildQualified>
               | <Expression> <OptionalAs> <AliasName>                  
               | <Expression>

<Restriction> ::= ALL
                | DISTINCT
                |

<IntoClause> ::= INTO <TableName>
               | INTO <VariableName>
               |

<FromClause> ::= FROM <Source> <JoinChain> <WhereClause> <GroupClause> <HavingClause> <OrderClause> 
               |

<JoinChain> ::= <Join> <JoinChain>
              |

<Join> ::= <JoinKind> JOIN <Source> ON <Predicate>
         | CROSS JOIN <Source>

<JoinKind> ::= <OptionalInner>
             | LEFT <OptionalOuter>
             | RIGHT <OptionalOuter>
             | FULL <OptionalOuter>

<OptionalInner> ::= INNER
              |

<OptionalOuter> ::= OUTER
              |

<Source> ::= <TableNameQualified>
           | <TableNameQualified> <OptionalAs> <AliasName>
           | '(' <SelectStatement> ')' <OptionalAs> <AliasName>

<WhereClause> ::= WHERE <Predicate>
                |

<GroupClause> ::= GROUP BY <ExpressionList>
                |

<OrderClause> ::= ORDER BY <OrderList>
                |

<Order> ::= <Expression> <OrderType>

<OrderList> ::= <Order> ',' <OrderList>
              | <Order>

<OrderType> ::= ASC
              | DESC
              |

<HavingClause> ::= HAVING <Predicate>
                 |

<UnionClause> ::= UNION <SelectGroup>
                | UNION ALL <SelectGroup>
                |

<SelectFor> ::= FOR <SelectForValue>
              |

<SelectForValue> ::= BROWSE
                   | XML <ForXml>

<ForXml> ::= RAW <ForXmlElementNameGroup> <ForXmlCommonDirectiveGroup> <ForXmlFormat> <ForXmlElements>
           | AUTO <ForXmlCommonDirectiveGroup> <ForXmlFormat> <ForXmlElements>
           | EXPLICIT <ForXmlCommonDirectiveGroup> <ForXmlFormat>
           | PATH <ForXmlElementNameGroup> <ForXmlCommonDirectiveGroup> <ForXmlElements>

<ForXmlElementNameGroup> ::= '(' <XmlElementName> ')'
                           |

<ForXmlCommonDirectiveGroup> ::= ',' BINARY BASE64
                               | ',' TYPE
                               | ',' ROOT <ForXmlElementNameGroup>
                               
<ForXmlFormat> ::= ',' XMLDATA
                 | ',' XMLSCHEMA <ForXmlNamespaceNameGroup>

<ForXmlNamespaceNameGroup> ::= '(' <XmlNamespaceName> ')'
                             |

<ForXmlElements> ::= ',' ELEMENTS <ForXmlElementsType>

<ForXmlElementsType> ::= XSINIL
                       | ABSENT

! ============================================================================= 
! Pedicated and Expressions
! =============================================================================

<Predicate> ::= <AndExp> OR <Predicate>
              | <AndExp>

<AndExp> ::= <NotExp> AND <AndExp>
           | <NotExp>

<NotExp> ::= NOT <PredExp>
           | <PredExp>

<PredBetweenOp> ::= BETWEEN
                  | NOT BETWEEN

<PredBinaryOp> ::= '='
                 | '<>'
                 | '!='
                 | '>'
                 | '>='
                 | '<'
                 | '<='

<PredExp> ::= <Expression> <PredBetweenOp> <Expression> AND <Expression>
            | <Expression> IS <NullCheck>
            | <Expression> <OptionalNot> LIKE StringLiteral <Escape>
            | <Expression> <OptionalNot> IN <Tuple>
            | <Expression> <PredBinaryOp> <Expression>
            | EXISTS '(' <SelectStatement> ')'

<Escape> ::= ESCAPE <StringLiteral>
           |

<Expression> ::= <MultExp> <AddBinaryOp> <Expression>
               | <MultExp>

<AddBinaryOp> ::= '+'
                | '-'

<MultExp> ::= <MultExp> <MultBinaryOp> <NegateExp> 
            | <NegateExp>

<MultBinaryOp> ::= '*'
                 | '/'

<NegateExp> ::= '-' <Function>
              | <Function>

<Function> ::= COUNT '(' <Restriction> <ColumnWildNameQualified> ')'
             | <FunctionName> '(' ')'
             | <FunctionName> '(' <ExpressionList> ')'
             | <Case>

<Case> ::= CASE <Expression> <CaseWhenExpressionList> END
         | CASE <CaseWhenExpressionList> END
         | <Value>

<CaseWhenExpressionList> ::= <CaseWhenExpression> <CaseWhenExpressionList>
                           | <CaseWhenExpression> <CaseElseExpression>
                           
<CaseWhenExpression> ::= WHEN <Predicate> THEN <Expression>

<CaseElseExpression> ::= ELSE <Expression>
                       |
     
<Value> ::= <Tuple>
          | <ColumnNameQualified>
          | <VariableName>
          | <SystemVariableName>
          | <Literal>

<Tuple> ::= '(' <SelectStatement> ')'
          | '(' <ExpressionList> ')'

<ExpressionList> ::= <Expression> ',' <ExpressionList>
                   | <Expression>

