! -----------------------------------------------------------------------------------
! T-SQL Script Analyzer
! -----------------------------------------------------------------------------------

"Name"         = 'T-SQL CREATE Statements'
"Version"      = '2005'
"About"        = 'Parser for T-SQL subset'
"Author"       = 'Arsene von Wyss'

"Start Symbol" = <Root>

! CLR UDTs are missing, but may be implemented later

! =============================================================================
! Comments
! =============================================================================

Comment Start = '/*'
Comment End   = '*/'
Comment Line  = '--'

! =============================================================================
! Terminals
! =============================================================================

{String Ch}        = {Printable} - ["]
{Id Ch Standard}   = {Alphanumeric} + [_]
{Id Ch Extended}   = {Printable} - ['['#']']
{Hex Ch}           = [0123456789ABCDEF]
{Nonspace Ch}      = {Printable} - {Whitespace}

StringLiteral   = N?(''{String Ch}*'')+
IntegerLiteral  = {Digit}+
RealLiteral     = {Digit}+'.'{Digit}+
HexLiteral      = 0x{Hex Ch}+

! We use a simplified name convention, which does not allow user/schema, database or server to be specified
Id             = {Letter}{Id Ch Standard}* | '['{Id Ch Extended}+']' | '"'{Id Ch Standard}*'"'
LocalId        = '@'{Letter}{Id Ch Standard}*
SystemId       = '@@'{Letter}{Id Ch Standard}*
TempTableId    = '#'{Letter}{Id Ch Standard}* | '[#'{Id Ch Extended}+']' | '"#'{Id Ch Standard}*'"'

! The reserved keywords as per MSDN: http://msdn.microsoft.com/en-us/library/ms189822.aspx
! By specifying them explicitly here, we should not see those in the log as implicit when generating the grammar tables, and the unsed ones are still reserved keywords
ADD = ADD
EXISTS = EXISTS
PRECISION = PRECISION
ALL = ALL
EXIT = EXIT
PRIMARY = PRIMARY
ALTER = ALTER
EXTERNAL = EXTERNAL
PRINT = PRINT
AND = AND
FETCH = FETCH
! PROC = PROC -- is covered by PROCEDURE
ANY = ANY
FILE = FILE
PROCEDURE = PROC(EDURE)?
AS = AS
FILLFACTOR = FILLFACTOR
PUBLIC = PUBLIC
ASC = ASC
FOR = FOR
RAISERROR = RAISERROR
AUTHORIZATION = AUTHORIZATION
FOREIGN = FOREIGN
READ = READ
BACKUP = BACKUP
FREETEXT = FREETEXT
READTEXT = READTEXT
BEGIN = BEGIN
FREETEXTTABLE = FREETEXTTABLE
RECONFIGURE = RECONFIGURE
BETWEEN = BETWEEN
FROM = FROM
REFERENCES = REFERENCES
BREAK = BREAK
FULL = FULL
REPLICATION = REPLICATION
BROWSE = BROWSE
FUNCTION = FUNCTION
RESTORE = RESTORE
BULK = BULK
GOTO = GOTO
RESTRICT = RESTRICT
BY = BY
GRANT = GRANT
RETURN = RETURN
CASCADE = CASCADE
GROUP = GROUP
REVERT = REVERT
CASE = CASE
HAVING = HAVING
REVOKE = REVOKE
CHECK = CHECK
HOLDLOCK = HOLDLOCK
RIGHT = RIGHT
CHECKPOINT = CHECKPOINT
IDENTITY = IDENTITY
ROLLBACK = ROLLBACK
CLOSE = CLOSE
IDENTITY_INSERT = IDENTITY_INSERT
ROWCOUNT = ROWCOUNT
CLUSTERED = CLUSTERED
IDENTITYCOL = IDENTITYCOL
ROWGUIDCOL = ROWGUIDCOL
COALESCE = COALESCE
IF = IF
RULE = RULE
COLLATE = COLLATE
IN = IN
SAVE = SAVE
COLUMN = COLUMN
INDEX = INDEX
SCHEMA = SCHEMA
COMMIT = COMMIT
INNER = INNER
SECURITYAUDIT = SECURITYAUDIT
COMPUTE = COMPUTE
INSERT = INSERT
SELECT = SELECT
CONSTRAINT = CONSTRAINT
INTERSECT = INTERSECT
SESSION_USER = SESSION_USER
CONTAINS = CONTAINS
INTO = INTO
SET = SET
CONTAINSTABLE = CONTAINSTABLE
IS = IS
SETUSER = SETUSER
CONTINUE = CONTINUE
JOIN = JOIN
SHUTDOWN = SHUTDOWN
CONVERT = CONVERT
KEY = KEY
SOME = SOME
CREATE = CREATE
KILL = KILL
STATISTICS = STATISTICS
CROSS = CROSS
LEFT = LEFT
SYSTEM_USER = SYSTEM_USER
CURRENT = CURRENT
LIKE = LIKE
TABLE = TABLE
CURRENT_DATE = CURRENT_DATE
LINENO = LINENO
TABLESAMPLE = TABLESAMPLE
CURRENT_TIME = CURRENT_TIME
LOAD = LOAD
TEXTSIZE = TEXTSIZE
CURRENT_TIMESTAMP = CURRENT_TIMESTAMP
MERGE = MERGE
THEN = THEN
CURRENT_USER = CURRENT_USER
NATIONAL = NATIONAL
TO = TO
CURSOR = CURSOR
NOCHECK = NOCHECK
TOP = TOP
DATABASE = DATABASE
NONCLUSTERED = NONCLUSTERED
TRAN = TRAN
DBCC = DBCC
NOT = NOT
TRANSACTION = TRANSACTION
DEALLOCATE = DEALLOCATE
NULL = NULL
TRIGGER = TRIGGER
DECLARE = DECLARE
NULLIF = NULLIF
TRUNCATE = TRUNCATE
DEFAULT = DEFAULT
OF = OF
TSEQUAL = TSEQUAL
DELETE = DELETE
OFF = OFF
UNION = UNION
DENY = DENY
OFFSETS = OFFSETS
UNIQUE = UNIQUE
DESC = DESC
ON = ON
UNPIVOT = UNPIVOT
DISK = DISK
OPEN = OPEN
UPDATE = UPDATE
DISTINCT = DISTINCT
OPENDATASOURCE = OPENDATASOURCE
UPDATETEXT = UPDATETEXT
DISTRIBUTED = DISTRIBUTED
OPENQUERY = OPENQUERY
USE = USE
DOUBLE = DOUBLE
OPENROWSET = OPENROWSET
USER = USER
DROP = DROP
OPENXML = OPENXML
VALUES = VALUES
DUMP = DUMP
OPTION = OPTION
VARYING = VARYING
ELSE = ELSE
OR = OR
VIEW = VIEW
END = END
ORDER = ORDER
WAITFOR = WAITFOR
ERRLVL = ERRLVL
OUTER = OUTER
WHEN = WHEN
ESCAPE = ESCAPE
OVER = OVER
WHERE = WHERE
EXCEPT = EXCEPT
PERCENT = PERCENT
WHILE = WHILE
! EXEC = EXEC -- is covered by EXECUTE
PIVOT = PIVOT
WITH = WITH
EXECUTE = EXEC(UTE)?
PLAN = PLAN
WRITETEXT = WRITETEXT

! Compound reserved words to keep the grammar context-free
RETURNS_NULL_ON_NULL_INPUT = RETURNS{Whitespace}+NULL{Whitespace}+ON{Whitespace}+NULL{Whitespace}+INPUT
CALLED_ON_NULL_INPUT = CALLED{Whitespace}+ON{Whitespace}+NULL{Whitespace}+INPUT
FOR_XML = FOR{Whitespace}+XML
FOR_PATH = FOR{Whitespace}+PATH
FOR_VALUE = FOR{Whitespace}+VALUE
FOR_PROPERTY = FOR{Whitespace}+PROPERTY
XML_INDEX = XML{Whitespace}+INDEX
XML_SCHEMA_COLLECTION = XML{Whitespace}+SCHEMA{Whitespace}+COLLECTION
USING_XML_INDEX = USING{Whitespace}+XML{Whitespace}+INDEX
WITH_CHANGE_TRACKING = WITH{Whitespace}+CHANGE_TRACKING
WITH_RECOMPILE = WITH{Whitespace}+RECOMPILE
WITH_VIEW_METADATA = WITH{Whitespace}+VIEW_METADATA
WITH_CHECK_OPTION = WITH{Whitespace}+CHECK{Whitespace}+OPTION
ENABLE_TRIGGER = ENABLE{Whitespace}+TRIGGER
DISABLE_TRIGGER = DISABLE{Whitespace}+TRIGGER
ADD_PERSISTED = ADD{Whitespace}+PERSISTED
DROP_PERSISTED = DROP{Whitespace}+PERSISTED
BEGIN_TRY = BEGIN{Whitespace}+TRY
END_TRY = END{Whitespace}+TRY
BEGIN_CATCH = BEGIN{Whitespace}+CATCH
END_CATCH = END{Whitespace}+CATCH
FULLTEXT_INDEX = FULLTEXT{Whitespace}+INDEX
WITH_FILLFACTOR = WITH{Whitespace}+FILLFACTOR
NO_POPULATION = NO{Whitespace}+POPULATION
TYPE_COLUMN = TYPE{Whitespace}+COLUMN
PARTITION_BY = PARTITION{Whitespace}+BY
INSTEAD_OF = INSTEAD{Whitespace}+OF
INCLUDE_ = INCLUDE{Whitespace}*'('
COUNT_ = COUNT{Whitespace}*'('
CAST_ = CAST{Whitespace}*'('
_RETURNS = ')'{Whitespace}*RETURNS
LANGUAGE_LCID = LANGUAGE{Whitespace}+(0x{Hex Ch}+|{Digit}+|''{String Ch}+('-'{String Ch}+)?'')
OUTPUT = OUT(PUT)?

! =============================================================================
! Common Terminals (Names, Literals, ...)
! =============================================================================

<AliasName> ::= Id

<CollationName> ::= Id

<ColumnName> ::= Id

<ColumnNameQualified> ::= <ColumnName>
                        | <TableName> '.' <ColumnName>
                        | <VariableName> '.' <ColumnName>

<ColumnNameList> ::= <ColumnName> ',' <ColumnNameList>
                   | <ColumnName>

<ColumnWild> ::= '*'

<ColumnWildQualified> ::= <ColumnWild>
                        | <TableName> '.' <ColumnWild>
                        | <VariableName> '.' <ColumnWild>

<ColumnWildNameQualified> ::= <ColumnNameQualified>
                            | <ColumnWildQualified>

<ConstraintName> ::= Id

<FunctionName> ::= Id

<IndexName> ::= Id

<LabelName> ::= Id

<ParameterName> ::= LocalId

<ProcedureName> ::= Id

<ProcedureNameQualified> ::= <ProcedureName>
                           | <SchemaName> '.' <ProcedureName>

<TableName> ::= Id
              | TempTableId

<TableNameQualified> ::= <TableName>
                       | <SchemaName> '.' <TableName>

<TriggerName> ::= Id

<TypeName> ::= Id
             | Id '(' <IntegerLiteral> ')' ! e.g. VARCHAR(20)
             | Id '(' <IntegerLiteral> ',' <IntegerLiteral> ')' ! e.g. DECIMAL(10,5)

<TypeNameQualified> ::= <TypeName>
                      | <SchemaName> '.' <TypeName>

<SchemaName> ::= Id

<SystemVariableName> ::= SystemId

<VariableName> ::= LocalId

<ViewName> ::= Id

<XmlElementName> ::= Id

<XmlSchemaCollectionName> ::= Id

<OptionalAs> ::= AS
               |

<NullLiteral> ::= NULL

<OptionalNot> ::= NOT
                |

<NullCheck> ::= <NullLiteral>
              | NOT <NullLiteral>

<StringLiteral> ::= StringLiteral

<IntegerLiteral> ::= IntegerLiteral
                   | HexLiteral

<NumberLiteral> ::= <IntegerLiteral>
                  | RealLiteral

<Literal> ::= <NumberLiteral>
            | <StringLiteral>
            | <NullLiteral>

<Toggle> ::= ON
           | OFF

! =============================================================================
! Any statements allowed as SQL statements in code
! =============================================================================

<Root> ::= <StatementGroup>
         | <Statement>

! In T-SQL, the terminator (;) is usually not required. However, this introduces some ambiguities, so that we require it. 
<StatementGroup> ::= <StatementBlock>
                   | <Statement> ';'

<StatementBlock> ::= BEGIN <StatementList> END

<StatementList> ::= <StatementGroup> <StatementList>
                  | <StatementGroup>

<Statement> ::= <DDLStatement>
              | <DMLStatement>

<DDLStatement> ::= <CreateStatement>
                 | <DropStatement>
                 | <AlterStatement>

<CreateStatement> ::= <CreateFulltext>
                    | <CreateFunction>
                    | <CreateIndex>
                    | <CreateProcedure>
                    | <CreateTable>
                    | <CreateTrigger>
                    | <CreateView>
                    | <CreateXmlSchemaCollection>

<AlterStatement> ::= <AlterTable> ! We don't need anything but this to handle data update scripts

<DropStatement> ::= <DropFulltext>
                  | <DropFunction>
                  | <DropIndex>
                  | <DropProcedure>
                  | <DropTable>
                  | <DropTrigger>
                  | <DropView>
                  | <DropXmlSchemaCollection>

<DMLStatement> ::= <BreakStatement>
                 | <ContinueStatement>
                 | <GotoStatement>
                 | <IfStatement>
                 | <ReturnStatement>
                 | <TryCatchStatement>
                 | <WaitforStatement>
                 | <WhileStatement>
                 | <SelectStatement>
                 | <InsertStatement>
                 | <UpdateStatement>
                 | <DeleteStatement>
                 | <ExecuteStatement>
                 | <SetStatement>
                 | <DeclareStatement>

! =============================================================================
! Control-of-Flow and simple statements
! =============================================================================

<BreakStatement> ::= BREAK

<ContinueStatement> ::= CONTINUE

<GotoStatement> ::= GOTO <LabelName>

<IfStatement> ::= IF <Predicate> THEN <IfElseStatement>
                | IF <Predicate> <Statement>

! To avoid the hanging ELSE problem/ambiguity, we just require a block - even if this is more restrictive than T-SQL
<IfElseStatement> ::= <StatementBlock> ELSE <StatementGroup>
                    | <StatementGroup>

<ReturnStatement> ::= RETURN
                    | RETURN <Expression>

<TryCatchStatement> ::= BEGIN_TRY <StatementList> END_TRY BEGIN_CATCH <StatementList> END_CATCH

<WhileStatement> ::= WHILE <Expression> <StatementGroup>

<WaitforStatement> ::= WAITFOR Id <StringValue>

! =============================================================================
! Common helper constructs
! =============================================================================

<OptionalDefault> ::= '=' <Literal>
                    |

<ReadableRowset> ::= <VariableName>
                   | <TableNameQualified>
                   | '(' <SelectGroup> ')'
                   | <Openxml>

<WriteableRowset> ::= <VariableName>
                    | <TableName>
!                    | <Openrowset> -- not supported
!                    | <Openquery> -- not supported

<Openxml> ::= OPENXML '(' <VariableName> ',' <StringValue> <OptionalOpenxmlFlags> ')' <OptionalOpenxmlSchema>

<OptionalOpenxmlFlags> ::= ',' <IntegerLiteral>
                         |

<OptionalOpenxmlSchema> ::= WITH '(' <OpenxmlSchemaGroup> ')'
                          |

<OpenxmlSchemaGroup> ::= <TableNameQualified>
                       | <OpenxmlColumnList>

<OpenxmlColumnList> ::= <OpenxmlColumn> ',' <OpenxmlColumnList>
                      | <OpenxmlColumn>

<OpenxmlColumn> ::= <ColumnName> <TypeName> <OptionalOpenxmlColumnPattern>

<OptionalOpenxmlColumnPattern> ::= <StringLiteral>
                                 |

! =============================================================================
! SET (both variables and options, but not yet CLR UDT properties and fields)
! =============================================================================

<SetStatement> ::= <SetVariableStatement>
                 | <SetOptionStatement>

<SetVariableStatement> ::= SET <VariableName> '=' <Expression>

<SetOptionStatement> ::= SET Id <SetValueList>
                       | SET IDENTITY_INSERT <TableName> <Toggle>

<SetValueList> ::= <SetValue> <SetValueList>
                 | <SetValue>

<SetValue> ::= Id
             | <Toggle>
             | <IntegerLiteral>
             | <StringValue>

<StringValue> ::= <StringLiteral>
                | <VariableName>

! =============================================================================
! DECLARE
! =============================================================================

<DeclareStatement> ::= DECLARE <VariableName> CURSOR
                     | DECLARE <VariableName> <OptionalAs> <DeclareType>

<DeclareType> ::= <TypeNameQualified>
                | TABLE <TableTypeDefinitionGroup>

! =============================================================================
! CREATE/DROP FULLTEXT
! =============================================================================

! We don't allow to specify the catalog name, since the catalog is automatically assigned (module name)

<CreateFulltext> ::= CREATE FULLTEXT_INDEX ON TABLE <TableName> <FulltextColumnGroup> KEY INDEX <IndexName> <FulltextChangeTracking>

<FulltextColumnGroup> ::= '(' <FulltextColumnList> ')'
                        |

<FulltextColumnList> ::= <FulltextColumn> ',' <FulltextColumnList>
                       | <FulltextColumn>

<FulltextColumn> ::= <ColumnName> <FulltextColumnType> <FulltextColumnLanguage>

<FulltextColumnType> ::= TYPE_COLUMN <TypeNameQualified>
                       |

<FulltextColumnLanguage> ::= LANGUAGE_LCID
                           |

<FulltextChangeTracking> ::= WITH_CHANGE_TRACKING <FulltextChangeTrackingName>
                           |

<FulltextChangeTrackingName> ::= Id
                               | OFF
                               | OFF ',' NO_POPULATION

<DropFulltext> ::= DROP FULLTEXT_INDEX ON <TableName>

! =============================================================================
! CREATE/DROP FUNCTION
! =============================================================================

! We don't allow to specify the schema name, it is implicit (module name)

<CreateFunction> ::= CREATE FUNCTION <FunctionName> <FunctionParameterGroup> <FunctionType>

<FunctionParameterGroup> ::= '(' <FunctionParameterList> _RETURNS
                           | '(' _RETURNS

<FunctionParameterList> ::= <FunctionParameter> ',' <FunctionParameterList>
                          | <FunctionParameter>

<FunctionParameter> ::= <ParameterName> <OptionalAs> <TypeNameQualified> <OptionalDefault>

<FunctionType> ::= <FunctionScalar>
                 | <FunctionInline>
                 | <FunctionTable>

<FunctionScalar> ::= <TypeName> <FunctionOptionGroup> <OptionalAs> <StatementBlock>

<FunctionInline> ::= TABLE <FunctionOptionGroup> <OptionalAs> RETURN <FunctionInlineSelect>

<FunctionInlineSelect> ::= <SelectStatement>
                         | '(' <SelectStatement> ')'

<FunctionTable> ::= <VariableName> TABLE <TableTypeDefinitionGroup> <FunctionOptionGroup> <OptionalAs> <StatementBlock>

<FunctionOptionGroup> ::= WITH <FunctionOption>
                        |

! The options ENCRYPTION and SCHEMABINDING are handled by the module and therefore not allowed
<FunctionOption> ::= RETURNS_NULL_ON_NULL_INPUT
                   | CALLED_ON_NULL_INPUT

<DropFunction> ::= DROP FUNCTION <FunctionName>

! =============================================================================
! CREATE/DROP PROCEDURE and EXECUTE
! =============================================================================

<CreateProcedure> ::= CREATE PROCEDURE <ProcedureName> <ProcedureParameterGroup> <ProcedureOptionGroup> <ProcedureFor> AS <StatementBlock>

<ProcedureParameterGroup> ::= <ProcedureParameterList>
                            |

<ProcedureParameterList> ::= <ProcedureParameter> ',' <ProcedureParameterList>
                           | <ProcedureParameter>

<ProcedureParameter> ::= <ParameterName> <TypeNameQualified> <OptionalVarying> <OptionalDefault> <OptionalOutput>

<OptionalVarying> ::= VARYING
                    |

<OptionalOutput> ::= OUTPUT
                   |

<ProcedureOptionGroup> ::= WITH_RECOMPILE
                         |

<ProcedureFor> ::= FOR REPLICATION
                 |

<DropProcedure> ::= DROP PROCEDURE <ProcedureName>

<ExecuteStatement> ::= EXECUTE <OptionalVariableAssignment> <ProcedureNameQualified> <ExecuteParameterGroup> <ProcedureOptionGroup>

<ExecuteParameterGroup> ::= <ExecuteParameterList>
                          |

<ExecuteParameterList> ::= <ExecuteParameter> ',' <ExecuteParameterList>
                         | <ExecuteParameter>

<ExecuteParameter> ::= <TableNameQualified> ! for the system "sp_*" SPs
                     | <ParameterName> '=' <ExecuteParameterValue> <OptionalOutput>
                     | <ExecuteParameterValue> <OptionalOutput>

<ExecuteParameterValue> ::= <VariableName>
                          | <SystemVariableName>
                          | <Literal>

<OptionalVariableAssignment> ::= <VariableName> '='
                               |

! =============================================================================
! CREATE/ALTER/DROP TABLE
! =============================================================================

! We don't support the ON option, filegroup is managed by module manager

<CreateTable> ::= CREATE TABLE <TableName> <TableTypeDefinitionGroup> 

<AlterTable> ::= ALTER TABLE <TableName> <AlterTableKind>

<AlterTableKind> ::= <AlterColumn>
                   | <AddColumnOrConstraint>
                   | <DropColumn>
                   | <DropConstraint>

<AlterColumn> ::= ALTER COLUMN <ColumnName> <AlterColumnKind>

<AlterColumnKind> ::= <ColumnTypeDefinition>
                    | ADD <ColumnRowguid>
                    | DROP <ColumnRowguid>
                    | ADD_PERSISTED
                    | DROP_PERSISTED
                    | ADD <NotForReplication>
                    | DROP <NotForReplication>
                    | ADD <TableTypeDefinition>
                    | <WithCheck> ADD <TableTypeDefinition>
                    | <DropConstraint>
                    | <DropColumn>
                    | <WithCheck> <AlterConstraint> 
                    | <AlterConstraint>
                    | <EnableOrDisableTrigger>

<EnableOrDisableTrigger> ::= ENABLE_TRIGGER <AllOrTriggerNameList>
                           | DISABLE_TRIGGER <AllOrTriggerNameList>

<AllOrTriggerNameList> ::= ALL
                        | <TriggerNameList>

<TriggerNameList> ::= <TriggerName> ',' <TriggerNameList>
                    | <TriggerName>

<AlterConstraint> ::= <CheckOrNocheck> CONSTRAINT <AllOrConstraintNameList>

<AllOrConstraintNameList> ::= ALL
                        | <ConstraintNameList>

<ConstraintNameList> ::= <ConstraintName> ',' <ConstraintNameList>
                       | <ConstraintName>

<WithCheck> ::= WITH <CheckOrNocheck>

<CheckOrNocheck> ::= CHECK
                   | NOCHECK

<AddColumnOrConstraint> ::= ADD <ColumnOrConstraintList>

<ColumnOrConstraintList> ::= <ColumnOrConstraint> ',' <ColumnOrConstraintList>
                           | <ColumnOrConstraint>

<ColumnOrConstraint> ::= <ColumnDefinition>
                       | <TableConstraint>

<DropColumn> ::= DROP COLUMN <ColumnName>

<DropConstraint> ::= DROP CONSTRAINT <ConstraintName>
                   | DROP <ConstraintName>

<DropTable> ::= DROP TABLE <TableName>

! =============================================================================
! CREATE/DROP VIEW
! =============================================================================

<CreateView> ::= CREATE VIEW <ViewName> <ColumnNameGroup> <ViewOptionalAttribute> AS <SelectStatement> <ViewOptionalCheckOption>

<ColumnNameGroup> ::= '(' <ColumnNameList> ')'
                    |

<ViewOptionalAttribute> ::= WITH_VIEW_METADATA
                          |

<ViewOptionalCheckOption> ::= WITH_CHECK_OPTION
                            |

<DropView> ::= DROP VIEW <ViewName>

! =============================================================================
! CREATE/DROP INDEX
! =============================================================================

! We don't support the ON option, filegroup is managed by module manager

<CreateIndex> ::= CREATE <ConstraintUnique> <ConstraintCluster> INDEX <IndexName> ON <TableName> '(' <IndexColumnList> ')' <IndexInclude> <IndexOptionGroup>
                | CREATE <IndexPrimary> XML_INDEX <IndexName> ON <TableName> '(' <ColumnName> ')' <IndexUsing> <IndexOptionGroup>

<IndexColumnList> ::= <IndexColumn> ',' <IndexColumnList>
                    | <IndexColumn>

<IndexColumn> ::= <ColumnName> <OrderType> 

<IndexInclude> ::= INCLUDE_ <ColumnNameList> ')'

<IndexPrimary> ::= PRIMARY
                 |

<IndexOptionGroup> ::= WITH '(' <IndexOptionList> ')'
                     |

<IndexOptionList> ::= <IndexOption> ',' <IndexOptionList>
                    | <IndexOption>

<IndexOption> ::= <IndexOptionInteger>
                | <IndexOptionToggle>

<IndexOptionInteger> ::= Id '=' <IntegerLiteral>

<IndexOptionToggle> ::= Id '=' <Toggle>

<IndexUsing> ::= USING_XML_INDEX <IndexName> <IndexFor>
               |

<IndexFor> ::= FOR_VALUE
             | FOR_PATH
             | FOR_PROPERTY

<DropIndex> ::= DROP INDEX <IndexName> ON <TableName> <IndexOptionGroup>

! =============================================================================
! CREATE/DROP TRIGGER
! =============================================================================

! Only DML triggers are supported

<CreateTrigger> ::= CREATE TRIGGER <TriggerName> ON <TableName> <TriggerType> <TriggerOperationList> <OptionalNotForReplication> AS <Statement>

<TriggerType> ::= FOR
                | INSTEAD_OF
                | Id ! AFTER is not a keyword

<TriggerOperationList> ::= <TriggerOperation> ',' <TriggerOperationList>
                         | <TriggerOperation>

<TriggerOperation> ::= INSERT
                     | UPDATE
                     | DELETE

<OptionalNotForReplication> ::= <NotForReplication>
                              |

<NotForReplication> ::= NOT FOR REPLICATION

<DropTrigger> ::= DROP TRIGGER <TriggerName>

! =============================================================================
! CREATE/DROP XML SCHEMA COLLECTION
! =============================================================================

<CreateXmlSchemaCollection> ::= CREATE XML_SCHEMA_COLLECTION <XmlSchemaCollectionName> AS <Expression>

<DropXmlSchemaCollection> ::= DROP XML_SCHEMA_COLLECTION <XmlSchemaCollectionName>

! =============================================================================
! Table/Column Type Definitions
! =============================================================================

<TableTypeDefinitionGroup> ::= '(' <TableTypeDefinitionList> ')'

<TableTypeDefinitionList> ::= <TableTypeDefinition> ',' <TableTypeDefinitionList>
                            | <TableTypeDefinition>

! This does not match the BNF in the SQL Books Online 2005, but seems to be the correct syntax
<TableTypeDefinition> ::= <ColumnDefinition>
                        | <ColumnComputedDefinition>
                        | CONSTRAINT <ConstraintName> <TableConstraintList>

<TableConstraintList> ::= <TableConstraint> <TableConstraintList>
                        | <TableConstraint>

<TableConstraint> ::= <ConstraintPrimaryKey> <ConstraintCluster> <ConstraintIndex>
                    | <ConstraintCheck>

<ColumnDefinition> ::= <ColumnName> <ColumnTypeDefinition>

<ColumnTypeDefinition> ::= <TypeNameQualified> <ColumnKind> <ColumnConstraintGroup>

<ColumnKind> ::= <ColumnIdentity>
               | <ColumnRowguid>
               | <ColumnDefault> <ColumnCollate>

<ColumnIdentity> ::= IDENTITY <ColumnIdentityRange>

<ColumnIdentityRange> ::= '(' IntegerLiteral ',' IntegerLiteral ')'
                        |

<ColumnRowguid> ::= ROWGUIDCOL

<ColumnDefault> ::= <NamedConstraint> DEFAULT '(' <Literal> ')'
                  | DEFAULT <Literal> ! No idea if that is really right
                  |

<ColumnCollate> ::= COLLATE <CollationName>
                  |

<ColumnConstraintGroup> ::= <ColumnConstraintList>
                          |

<ColumnConstraintList> ::= <ColumnConstraint> <ColumnConstraintList>
                         | <ColumnConstraint>

! The syntax for multiple the constraint checks is not clear from the grammar in the SQL Books 2005 - and where does CONSTRAINT <ConstraintName> fit in?
<ColumnConstraint> ::= <NullCheck>
                     | <ConstraintPrimaryKey> <ConstraintCluster> <ConstraintIndex>
                     | <ConstraintCheck>

<NamedConstraint> ::= CONSTRAINT <ConstraintName>

<ColumnComputedDefinition> ::= <ColumnName> AS <Expression>

<ConstraintPrimaryKey> ::= PRIMARY KEY
                         | UNIQUE

<ConstraintUnique> ::= UNIQUE
                     |

<ConstraintCluster> ::= CLUSTERED
                      | NONCLUSTERED
                      |

<ConstraintCheck> ::= CHECK '(' <Expression> ')'

<ConstraintIndex> ::= WITH_FILLFACTOR '=' <IntegerLiteral>
                    | <IndexOptionGroup>

! =============================================================================
! Common Table Expressions and OUTPUT clause
! =============================================================================

<CTEGroup> ::= WITH <CTEList>
             |

<CTEList> ::= <CTE> ',' <CTEList>
            | <CTE>

<CTE> ::= <AliasName> AS '(' <SelectGroup> ')'

<OptionalOutputClause> ::= OUTPUT <OutputColumnList> <OutputIntoClause>
                         |

<OutputIntoClause> ::= INTO <TableName> <ColumnNameGroup>
                     | INTO <VariableName> <ColumnNameGroup>
                     |

<OutputColumnList> ::= <OutputColumn> ',' <OutputColumnList>
                     | <OutputColumn>

<OutputColumn> ::= <ColumnWildQualified> <OptionalAs> ! this includes DELETED and INSERTED pseudo-table names
                 | <Expression> <OptionalAs>

! =============================================================================
! INSERT Statement
! =============================================================================

<InsertStatement> ::= <CTEGroup> <InsertGroup>

<InsertGroup> ::= INSERT <Top> <OptionalInto> <WriteableRowset> <InsertData>

<InsertData> ::= <ColumnNameGroup> <OptionalOutputClause> <InsertSource>
               | DEFAULT VALUES

<OptionalInto> ::= INTO
                 |

<InsertSource> ::= VALUES '(' <ExpressionList> ')'
                 | <SelectGroup>
                 | <ExecuteStatement>


! =============================================================================
! UPDATE Statement
! =============================================================================

<UpdateStatement> ::= <CTEGroup> <UpdateGroup>

<UpdateGroup> ::= UPDATE <Top> <WriteableRowset> SET <UpdateColumnList> <OptionalOutputClause> <OptionalFromClause> <WhereClause>

<UpdateColumnList> ::= <UpdateColumn> ',' <UpdateColumnList>
                     | <UpdateColumn>

<UpdateColumn> ::= <ColumnNameQualified> '=' <ExpressionOrDefault>
                 | <VariableName> '=' <Expression>
                 | <VariableName> '=' <ColumnNameQualified> '=' <Expression>

<ExpressionOrDefault> ::= <Expression>
                        | DEFAULT

<OptionalFromClause> ::= <FromClause>
                       |

! =============================================================================
! DELETE Statement
! =============================================================================

<DeleteStatement> ::= <CTEGroup> <DeleteGroup>

<DeleteGroup> ::= DELETE <Top> <OptionalFrom> <WriteableRowset> <OptionalOutputClause> <OptionalFromClause> <WhereClause>

<OptionalFrom> ::= FROM
                 |

! =============================================================================
! SELECT Statement
! =============================================================================

<SelectStatement> ::= <CTEGroup> <SelectGroup> <SelectFor>

<SelectGroup> ::= SELECT <TopLegacy> <Columns> <IntoClause> <FromClauseFull> <UnionClause>

<TopLegacy> ::= TOP IntegerLiteral <OptionalPercent>
              | <Top>

<Top> ::= TOP '(' <Expression> ')' <OptionalPercent>
        |

<OptionalPercent> ::= PERCENT
                    |

<Columns> ::= <Restriction> <ColumnList>

<ColumnList> ::= <ColumnItem> ',' <ColumnList>
               | <ColumnItem>

<ColumnItem> ::= <ColumnWildQualified>
               | <Function> OVER '(' <PartitionByClause> ')' <OptionalAlias>
               | <Expression> <OptionalAlias>

<PartitionByClause> ::= PARTITION_BY <ExpressionList>
                      | <OrderClause>

<Restriction> ::= ALL
                | DISTINCT
                |

<IntoClause> ::= INTO <TableName>
               | INTO <VariableName>
               |

<FromClause> ::= FROM <Source> <JoinChain>

<FromClauseFull> ::= <FromClause> <WhereClause> <GroupClause> <HavingClause> <OrderClause> 
               |

<JoinChain> ::= <Join> <JoinChain>
              |

<Join> ::= <JoinKind> JOIN <Source> ON <Predicate>
         | CROSS JOIN <Source>

<JoinKind> ::= <OptionalInner>
             | LEFT <OptionalOuter>
             | RIGHT <OptionalOuter>
             | FULL <OptionalOuter>

<OptionalInner> ::= INNER
                  |

<OptionalOuter> ::= OUTER
                  |

<Source> ::= <ReadableRowset> <OptionalAlias>

<OptionalAlias> ::= <OptionalAs> <AliasName>
                  |

<WhereClause> ::= WHERE <Predicate>
                |

<GroupClause> ::= GROUP BY <ExpressionList>
                |

<OrderClause> ::= ORDER BY <OrderList>
                |

<OrderList> ::= <Order> ',' <OrderList>
              | <Order>

<Order> ::= <Expression> <OrderType>

<OrderType> ::= ASC
              | DESC
              |

<HavingClause> ::= HAVING <Predicate>
                 |

<UnionClause> ::= UNION <SelectGroup>
                | UNION ALL <SelectGroup>
                |

<SelectFor> ::= FOR BROWSE
              | FOR_XML <SelectForList>
              |

<SelectForList> ::= <SelectForIdList>
                  | <SelectForIdList> ',' <SelectForList>

<SelectForIdList> ::= Id <SelectForIdList>
                    | Id '(' <XmlElementName> ')'
                    | Id '(' <StringLiteral> ')'
                    | Id
           
! ============================================================================= 
! Pedicates and Expressions
! =============================================================================

<Predicate> ::= <AndExp> OR <Predicate>
              | <AndExp>

<AndExp> ::= <NotExp> AND <AndExp>
           | <NotExp>

<NotExp> ::= NOT <PredExp>
           | <PredExp>

<PredBetweenOp> ::= BETWEEN
                  | NOT BETWEEN

<PredBinaryOp> ::= '='
                 | '<>'
                 | '>'
                 | '>='
                 | '<'
                 | '<='

<PredExp> ::= <Expression> <PredBetweenOp> <Expression> AND <Expression>
            | <Expression> IS <NullCheck>
            | <Expression> <OptionalNot> LIKE <StringLiteral> <Escape>
            | <Expression> <OptionalNot> IN <Tuple>
            | <Expression> <PredBinaryOp> <Expression>
            | EXISTS '(' <SelectGroup> ')'
            | '(' <Predicate> ')'

<Escape> ::= ESCAPE <StringLiteral>
           |

<Expression> ::= <MultExp> <AddBinaryOp> <Expression>
               | <MultExp>

<AddBinaryOp> ::= '+'
                | '-'

<MultExp> ::= <MultExp> <MultBinaryOp> <NegateExp> 
            | <NegateExp>

<MultBinaryOp> ::= '*'
                 | '/'

<NegateExp> ::= '-' <Function>
              | <Function>

<Function> ::= <CountFunction>
             | <CastFunction>
             | <CoalesceFunction>
             | <FunctionName> '(' ')'
             | <FunctionName> '(' <ExpressionList> ')'
             | <Case>

<CountFunction> ::= COUNT_ <Restriction> <ColumnWildNameQualified> ')'

<CastFunction> ::= CAST_ <Expression> AS <TypeName> ')'

<CoalesceFunction> ::= COALESCE '(' <ExpressionList> ')'

<Case> ::= CASE <Expression> <CaseWhenExpressionList> END
         | CASE <CaseWhenExpressionList> END
         | <Value>

<CaseWhenExpressionList> ::= <CaseWhenExpression> <CaseWhenExpressionList>
                           | <CaseWhenExpression> <CaseElseExpression>
                           
<CaseWhenExpression> ::= WHEN <Predicate> THEN <Expression>

<CaseElseExpression> ::= ELSE <Expression>
                       |
     
<Value> ::= <Tuple>
          | <ColumnNameQualified>
          | <VariableName> ! CLR UDT property, field and methods are not yet implemented
          | <SystemVariableName>
          | <Literal>

<Tuple> ::= '(' <SelectGroup> ')'
          | '(' <ExpressionList> ')'

<ExpressionList> ::= <Expression> ',' <ExpressionList>
                   | <Expression>

